#include <cstddef>
#include <err.h>
#include <fstream>
#include <iostream>
#include <seccomp.h>
#include <stdio.h>
#include <sys/prctl.h>
#include <sys/types.h>
#include <sys/utsname.h>
#include <unistd.h>

static void sandbox(void)
{
    // While just banning dangerous syscalls could be much better for mantaining this library, I don't trust that I would be able to comprehensively list them
    // This list was generated by looking at the emitted syscalls from godot

    // Maybe would could limit this more? Surely some of these are used but not absoloutely required.
    const char *permitted_syscalls[] = {
        "access",
        "arch_prctl",
        "brk",
        "chdir",
        "clock_gettime",
        "clone3",
        "close",
        "connect",
        "execve",
        "exit_group",
        "fadvise64",
        "fcntl",
        "fstat",
        "fstatfs",
        "ftruncate",
        "futex",
        "getcwd",
        "getdents64",
        "getegid",
        "geteuid",
        "getgid",
        "getpeername",
        "getpid",
        "getrandom",
        "getresgid",
        "getresuid",
        "getsockname",
        "getsockopt",
        "gettid",
        "getuid",
        "ioctl",
        "lseek",
        "lstat",
        "memfd_create",
        "mkdir",
        "mmap",
        "mprotect",
        "mremap",
        "munmap",
        "newfstatat",
        "openat",
        "pipe2",
        "poll",
        "ppoll",
        "prctl",
        "pread64",
        "prlimit64",
        "read",
        "readlink",
        "recvfrom",
        "recvmsg",
        "rmdir",
        "rseq",
        "rt_sigaction",
        "rt_sigprocmask",
        "sched_getaffinity",
        "sched_get_priority_max",
        "sched_get_priority_min",
        "sched_setaffinity",
        "sched_yield",
        "sendmsg",
        "sendto",
        "set_robust_list",
        "setsockopt",
        "set_tid_address",
        "socket",
        "socketpair",
        "stat",
        "statfs",
        "symlink",
        "sysinfo",
        "umask",
        "uname",
        "unlink",
        "vfork",
        "wait4",
        "write",
        "writev",
    };

    // Block ALL syscalls, we will punch holes in this.
    // ERRNO 1 seems to allow the process to continue, even if the syscall fails.

    // uint action = SCMP_ACT_LOG;
    // uint action = SCMP_ACT_ERRNO(1);
    uint action = SCMP_ACT_KILL;
    // uint action = SCMP_ACT_TRAP;

    scmp_filter_ctx seccomp_ctx = seccomp_init(action);
    if (!seccomp_ctx)
        err(1, "seccomp_init failed");

    // Punch holes for every syscall we need.
    for (int i = 0;
         i < sizeof(permitted_syscalls) / sizeof(permitted_syscalls[0]); i++)
    {
        const char *syscall = permitted_syscalls[i];
        if (seccomp_rule_add_exact(seccomp_ctx, SCMP_ACT_ALLOW,
                                   seccomp_syscall_resolve_name(syscall), 0))
        {
            perror("seccomp_rule_add_exact failed");
            exit(1);
        }
    }

    /* apply the composed filter */
    if (seccomp_load(seccomp_ctx))
    {
        perror("seccomp_load failed");
        exit(1);
    }

    /* release allocated context */
    seccomp_release(seccomp_ctx);

    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) == -1)
        err(0, "PR_SET_NO_NEW_PRIVS failed");
}

int main(int argc, char *argv[])
{
    sandbox();

    char *program_path = argv[1];
    for (int i = 1; i < argc - 2; ++i)
    {
        argv[i] = argv[i + 2];
    }
    execv(program_path, argv);

    return 0;
}
